<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libfranka: joint_impedance_control.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/NativeMML"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_FRANKA_EMIKA_dark.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libfranka
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">FCI C++ API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">joint_impedance_control.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>An example showing a joint impedance type control that executes a Cartesian motion in the shape of a circle. The example illustrates how to use the internal inverse kinematics to map a Cartesian trajectory to joint space. The joint space target is tracked by an impedance control that additionally compensates coriolis terms using the libfranka model library. This example also serves to compare commanded vs. measured torques. The results are printed from a separate thread to avoid blocking print functions in the real-time loop.</p>
<div class="fragment"><div class="line"><span class="comment">// Copyright (c) 2017 Franka Emika GmbH</span></div><div class="line"><span class="comment">// Use of this source code is governed by the Apache-2.0 license, see LICENSE</span></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="duration_8h.html">franka/duration.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="exception_8h.html">franka/exception.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="model_8h.html">franka/model.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="robot_8h.html">franka/robot.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>{</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">size_t</span> N&gt;</div><div class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostream, const std::array&lt;T, N&gt;&amp; array) {</div><div class="line">  ostream &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div><div class="line">  std::copy(array.cbegin(), array.cend() - 1, std::ostream_iterator&lt;T&gt;(ostream, <span class="stringliteral">&quot;,&quot;</span>));</div><div class="line">  std::copy(array.cend() - 1, array.cend(), std::ostream_iterator&lt;T&gt;(ostream));</div><div class="line">  ostream &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;</div><div class="line">  <span class="keywordflow">return</span> ostream;</div><div class="line">}</div><div class="line">}  <span class="comment">// anonymous namespace</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">  <span class="comment">// Check whether the required arguments were passed.</span></div><div class="line">  <span class="keywordflow">if</span> (argc != 5) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: ./&quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;robot-hostname&gt;&quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; &lt;radius in [m]&gt;&quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; &lt;vel_max in [m/s]&gt;&quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; &lt;print_rate in [Hz]&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Set and initialize trajectory parameters.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> radius = std::stod(argv[2]);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> vel_max = std::stod(argv[3]);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> acceleration_time = 2.0;</div><div class="line">  <span class="keywordtype">double</span> vel_current = 0.0;</div><div class="line">  <span class="keywordtype">double</span> angle = 0.0;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> time = 0.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> run_time = 20.0;</div><div class="line"></div><div class="line">  <span class="comment">// Set print rate for comparing commanded vs. measured torques.</span></div><div class="line">  <span class="keywordtype">double</span> print_rate = std::stod(argv[4]);</div><div class="line">  <span class="keywordflow">if</span> (print_rate &lt; 0.0) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;print_rate too small, must be &gt;= 0.0&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Initialize data fields for the print thread.</span></div><div class="line">  <span class="keyword">struct </span>{</div><div class="line">    std::mutex mutex;</div><div class="line">    <span class="keywordtype">bool</span> has_data;</div><div class="line">    std::array&lt;double, 7&gt; tau_d_last;</div><div class="line">    <a name="_a0"></a><a class="code" href="structfranka_1_1RobotState.html">franka::RobotState</a> robot_state;</div><div class="line">    std::array&lt;double, 7&gt; gravity;</div><div class="line">  } print_data{};</div><div class="line">  std::atomic_bool running{<span class="keyword">true</span>};</div><div class="line"></div><div class="line">  <span class="comment">// Start print thread.</span></div><div class="line">  std::thread print_thread([print_rate, &amp;print_data, &amp;running]() {</div><div class="line">    <span class="keywordflow">while</span> (running) {</div><div class="line">      <span class="comment">// Sleep to achieve the desired print rate.</span></div><div class="line">      std::this_thread::sleep_for(</div><div class="line">          std::chrono::milliseconds(static_cast&lt;int&gt;((1.0 / print_rate * 1000.0))));</div><div class="line"></div><div class="line">      <span class="comment">// Try to lock data to avoid read write collisions.</span></div><div class="line">      <span class="keywordflow">if</span> (print_data.mutex.try_lock() &amp;&amp; print_data.has_data) {</div><div class="line">        std::array&lt;double, 7&gt; tau_error{};</div><div class="line">        <span class="keywordtype">double</span> error_rms(0.0);</div><div class="line">        std::array&lt;double, 7&gt; tau_d_actual{};</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 7; ++i) {</div><div class="line">          tau_d_actual[i] = print_data.tau_d_last[i] + print_data.gravity[i];</div><div class="line">          tau_error[i] = tau_d_actual[i] - print_data.robot_state.tau_J[i];</div><div class="line">          error_rms += std::sqrt(std::pow(tau_error[i], 2.0)) / tau_error.size();</div><div class="line">        }</div><div class="line">        <span class="comment">// Print data to console</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;tau_error [Nm]: &quot;</span> &lt;&lt; tau_error &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;tau_commanded [Nm]: &quot;</span> &lt;&lt; tau_d_actual &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;tau_measured [Nm]: &quot;</span> &lt;&lt; print_data.robot_state.tau_J &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;root mean square of tau_error [Nm]: &quot;</span> &lt;&lt; error_rms &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;-----------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line">        print_data.has_data = <span class="keyword">false</span>;</div><div class="line">        print_data.mutex.unlock();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  });</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="comment">// Connect to robot.</span></div><div class="line">    <a name="_a1"></a><a class="code" href="classfranka_1_1Robot.html">franka::Robot</a> robot(argv[1]);</div><div class="line"></div><div class="line">    <span class="comment">// Set collision behavior.</span></div><div class="line">    robot.<a name="a2"></a><a class="code" href="classfranka_1_1Robot.html#a168e1214ac36d74ac64f894332b84534">setCollisionBehavior</a>(</div><div class="line">        {{20.0, 20.0, 18.0, 18.0, 16.0, 14.0, 12.0}}, {{20.0, 20.0, 18.0, 18.0, 16.0, 14.0, 12.0}},</div><div class="line">        {{20.0, 20.0, 18.0, 18.0, 16.0, 14.0, 12.0}}, {{20.0, 20.0, 18.0, 18.0, 16.0, 14.0, 12.0}},</div><div class="line">        {{20.0, 20.0, 20.0, 25.0, 25.0, 25.0}}, {{20.0, 20.0, 20.0, 25.0, 25.0, 25.0}},</div><div class="line">        {{20.0, 20.0, 20.0, 25.0, 25.0, 25.0}}, {{20.0, 20.0, 20.0, 25.0, 25.0, 25.0}});</div><div class="line"></div><div class="line">    <span class="comment">// Load the kinematics and dynamics model.</span></div><div class="line">    <a name="_a3"></a><a class="code" href="classfranka_1_1Model.html">franka::Model</a> model = robot.<a name="a4"></a><a class="code" href="classfranka_1_1Robot.html#a2da598c539469827409ac7e3bb61d5da">loadModel</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Read the initial pose to start the motion from there.</span></div><div class="line">    std::array&lt;double, 16&gt; initial_pose = robot.<a name="a5"></a><a class="code" href="classfranka_1_1Robot.html#a7ea7074a07b63fcf6933e97b078c7168">readOnce</a>().<a name="a6"></a><a class="code" href="structfranka_1_1RobotState.html#a193781d47722b32925e0ea7ac415f442">O_T_EE</a>;</div><div class="line"></div><div class="line">    <span class="comment">// Define callback function to send Cartesian pose goals to get inverse kinematics solved.</span></div><div class="line">    std::function&lt;franka::CartesianPose(const franka::RobotState&amp;, franka::Duration)&gt;</div><div class="line">        cartesian_pose_callback = [=, &amp;time, &amp;vel_current, &amp;running, &amp;angle](</div><div class="line">            <span class="keyword">const</span> <a class="code" href="structfranka_1_1RobotState.html">franka::RobotState</a>&amp; <span class="comment">/*state*/</span>, <a name="_a7"></a><a class="code" href="classfranka_1_1Duration.html">franka::Duration</a> period) -&gt; <a name="_a8"></a><a class="code" href="classfranka_1_1CartesianPose.html">franka::CartesianPose</a> {</div><div class="line">      <span class="comment">// Update time.</span></div><div class="line">      time += period.toSec();</div><div class="line"></div><div class="line">      <span class="comment">// Compute Cartesian velocity.</span></div><div class="line">      <span class="keywordflow">if</span> (vel_current &lt; vel_max &amp;&amp; time &lt; run_time) {</div><div class="line">        vel_current += period.toSec() * std::fabs(vel_max / acceleration_time);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">if</span> (vel_current &gt; 0.0 &amp;&amp; time &gt; run_time) {</div><div class="line">        vel_current -= period.toSec() * std::fabs(vel_max / acceleration_time);</div><div class="line">      }</div><div class="line">      vel_current = std::fmax(vel_current, 0.0);</div><div class="line">      vel_current = std::fmin(vel_current, vel_max);</div><div class="line"></div><div class="line">      <span class="comment">// Compute new angle for our circular trajectory.</span></div><div class="line">      angle += period.toSec() * vel_current / std::fabs(radius);</div><div class="line">      <span class="keywordflow">if</span> (angle &gt; 2 * M_PI) {</div><div class="line">        angle -= 2 * M_PI;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="comment">// Compute relative y and z positions of desired pose.</span></div><div class="line">      <span class="keywordtype">double</span> delta_y = radius * (1 - std::cos(angle));</div><div class="line">      <span class="keywordtype">double</span> delta_z = radius * std::sin(angle);</div><div class="line">      <a class="code" href="classfranka_1_1CartesianPose.html">franka::CartesianPose</a> pose_desired = initial_pose;</div><div class="line">      pose_desired.<a name="a9"></a><a class="code" href="classfranka_1_1CartesianPose.html#a406e53e3d8fe594a11888f516eb4bf7d">O_T_EE</a>[13] += delta_y;</div><div class="line">      pose_desired.<a class="code" href="classfranka_1_1CartesianPose.html#a406e53e3d8fe594a11888f516eb4bf7d">O_T_EE</a>[14] += delta_z;</div><div class="line"></div><div class="line">      <span class="comment">// Send desired pose.</span></div><div class="line">      <span class="keywordflow">if</span> (time &gt;= run_time + acceleration_time) {</div><div class="line">        running = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">return</span> <a name="a10"></a><a class="code" href="control__types_8h.html#a6225fb95e173faab34da66b551a80483">franka::MotionFinished</a>(pose_desired);</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> pose_desired;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Set gains for the joint impedance control.</span></div><div class="line">    <span class="comment">// Stiffness</span></div><div class="line">    <span class="keyword">const</span> std::array&lt;double, 7&gt; k_gains = {{1000.0, 1000.0, 1000.0, 1000.0, 500.0, 300.0, 100.0}};</div><div class="line">    <span class="comment">// Damping</span></div><div class="line">    <span class="keyword">const</span> std::array&lt;double, 7&gt; d_gains = {{100.0, 100.0, 100.0, 100.0, 50.0, 30.0, 10.0}};</div><div class="line"></div><div class="line">    <span class="comment">// Define callback for the joint torque control loop.</span></div><div class="line">    std::function&lt;franka::Torques(const franka::RobotState&amp;, franka::Duration)&gt;</div><div class="line">        impedance_control_callback = [&amp;print_data, &amp;model, k_gains, d_gains](</div><div class="line">            <span class="keyword">const</span> franka::RobotState&amp; state, <a class="code" href="classfranka_1_1Duration.html">franka::Duration</a> <span class="comment">/*period*/</span>) -&gt; <a name="_a11"></a><a class="code" href="classfranka_1_1Torques.html">franka::Torques</a> {</div><div class="line">      <span class="comment">// Read current coriolis terms from model.</span></div><div class="line">      std::array&lt;double, 7&gt; coriolis = model.coriolis(</div><div class="line">          state, {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}}, 0.0, {{0.0, 0.0, 0.0}});</div><div class="line"></div><div class="line">      <span class="comment">// Compute torque command from joint impedance control law.</span></div><div class="line">      <span class="comment">// Note: The answer to our Cartesian pose inverse kinematics is always in state.q_d with one</span></div><div class="line">      <span class="comment">// time step delay.</span></div><div class="line">      std::array&lt;double, 7&gt; tau_d;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 7; i++) {</div><div class="line">        tau_d[i] =</div><div class="line">            k_gains[i] * (state.q_d[i] - state.q[i]) - d_gains[i] * state.dq[i] + coriolis[i];</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="comment">// Update data to print.</span></div><div class="line">      <span class="keywordflow">if</span> (print_data.mutex.try_lock()) {</div><div class="line">        print_data.has_data = <span class="keyword">true</span>;</div><div class="line">        print_data.robot_state = state;</div><div class="line">        print_data.tau_d_last = tau_d;</div><div class="line">        print_data.gravity = model.gravity(state, 0.0, {{0.0, 0.0, 0.0}});</div><div class="line">        print_data.mutex.unlock();</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="comment">// Send torque command.</span></div><div class="line">      <span class="keywordflow">return</span> tau_d;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Start real-time control loop.</span></div><div class="line">    robot.<a name="a12"></a><a class="code" href="classfranka_1_1Robot.html#adccee7867c3f8fcff398ef34dadb723e">control</a>(impedance_control_callback, cartesian_pose_callback);</div><div class="line"></div><div class="line">  } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a name="_a13"></a><a class="code" href="structfranka_1_1Exception.html">franka::Exception</a>&amp; ex) {</div><div class="line">    running = <span class="keyword">false</span>;</div><div class="line">    std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (print_thread.joinable()) {</div><div class="line">    print_thread.join();</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
